<style>
rect.box {
    fill:none; 
    stroke:royalblue;
    stroke-width:0; 
    shape-rendering: crispEdges;
}
g.bubbles circle {
    fill:rgba(255,0,64,0.5); 
    stroke:rgb(255,0,64);
    stroke-width:1;
}
g.bubbles text {
    fill:royalblue;
    font-family:sans-serif;
    text-anchor:middle;
    alignment-baseline:middle;
    opacity:0;
    pointer-events:all;
    transition:1s;
}
g.bubbles text:hover {
    opacity:1;
}

div.tooltip { 
    position: absolute;     
    text-align: left;     
/*    width: 60px;          
    height: 28px;   */      
    padding: 2px;       
    font: 12px sans-serif;    
    background: lightsteelblue; 
    border: 0px;    
    border-radius: 8px;     
    pointer-events: none;     
    line-height: 1;
    font-weight: bold;
    padding: 12px;
    background: rgba(0, 0, 0, 0.5);
    color: #fff;
    border-radius: 2px;
}

#graph{
  border: 1px solid red;
}

</style>

<div class="col-md-12">
  <svg id="graph">
</svg>
</div >
<script src="/assets/js/d3.v3.min.js"></script>
<script src="/assets/js/jquery.min.js"></script>
<script>
 

//parameters//
var N = 25; //number of nodes
var sortOrder = -1; 
   //>0 for ascending, <0 for descending, 0 for no sort 

// Define the div for the tooltip
var div = d3.select("body").append("div") 
    .attr("class", "tooltip")       
    .style("opacity", 0);

d3.csv("/assets/data/budget.csv", function(csv_data){
  maindata=[]
  for (var k = 1, len = csv_data.length; k < len; k++) {
  console.log("CSV:"+JSON.stringify(csv_data[k]));
  pct_of_total= +csv_data[k].pct_of_total;
  pct_change= +csv_data[k].pct_change;
  ty= +csv_data[k].ty;
  id= csv_data[k].id;
  ly= +csv_data[k].ly;
  maindata.push({id:id, size:pct_of_total, pct_change:pct_change, ty:ty, ly:ly});
}

var MoneyFormat = function (labelValue) 
  {
  // Nine Zeroes for Billions
  return Math.abs(Number(labelValue)) >= 1.0e+9

       ? (Math.abs(Number(labelValue)) / 1.0e+9).toFixed(1) + "B"
       // Six Zeroes for Millions 
       : Math.abs(Number(labelValue)) >= 1.0e+6

       ? (Math.abs(Number(labelValue)) / 1.0e+6).toFixed(1) + "M"
       // Three Zeroes for Thousands
       : Math.abs(Number(labelValue)) >= 1.0e+3

       ? (Math.abs(Number(labelValue)) / 1.0e+3).toFixed(1) + "K"

       : Math.abs(Number(labelValue));

   }
 
var PctFormat = function (labelValue) 
  {
  // Nine Zeroes for Billions

  return (Number(labelValue) * 100) > 0 ? "+"+(Number(labelValue) * 100).toFixed(2) + "%" : (Number(labelValue) * 100).toFixed(2) + "%"


   }  
console.log("MyMainData:"+JSON.stringify(maindata))

//create data array//
var data = maindata, i = N;
// var randNorm = d3.random.normal(1,0.6);
// while(i--) data.push({ 
//     "size": Math.max(randNorm(), 0.1) });
    //circle area will be proportional to size  


console.log("Data:"+JSON.stringify(data));
    
var dataMax = d3.max(data, function(d){return d.size;});    
var changeMin = d3.min(data, function(d){return d.pct_change;});     
var changeMax = d3.max(data, function(d){return d.pct_change;});     
var totalSize = d3.sum(data, function(d){return d.size;});
    
    console.log(JSON.stringify(data));

//Set up SVG and rectangle//   
var svg = d3.select("#graph");
var digits = /(\d*)/;
var margin = 50; //space in pixels from edges of SVG
var padding = 4; //space in pixels between circles

var svgStyles = window.getComputedStyle(svg.node());


var initialwidth = $("#graph").parent().width();
var initialheight = initialwidth;
var width = (initialwidth*0.8) -(2*margin);
var height = (initialheight*0.8) -(2* margin) ;
// var height =  - 2*margin;





chart = d3.select('#graph')
      .attr("width", width)
      .attr("height", height);
d3.select(window)
  .on("resize", function() {
    var targetWidth = chart.node().getBoundingClientRect().width;
    chart.attr("width", targetWidth);
    chart.attr("height", targetWidth / aspect);
  });


// console.log("myparentwidth:"+ xyz);
console.log("height:"+ height);

var usableArea = Math.PI*
    Math.pow( Math.min(width,height)/2 ,2)*0.667;

console.log("Usablearea:"+usableArea);  
var scaleFactor = Math.sqrt(usableArea)/
        Math.sqrt(totalSize)/Math.PI;
var rScale = d3.scale.sqrt()  
        //make radius proportional to square root of data r
        .domain([0, dataMax]) //data range
        .range([0,  Math.sqrt(dataMax)*scaleFactor]);
//The rScale range will be adjusted as necessary
//during packing.
//The initial value is based on scaling such that the total
//area of the circles is 2/3 the area of the largest circle
//you can draw within the box.
    
/*
    console.log("Dimensions: ", [height, width]);
    console.log("area", width*height);
    console.log("Usable area: ", usableArea);
    console.log("TotalSize: ", totalSize);
    console.log("Initial Scale: ", scaleFactor);
    console.log("RScale: ",rScale.domain(), rScale.range());
console.log("r(1)", rScale(1) );
//  */  

var box = svg.append("rect")
            .attr({ "height": height, "width":width,
                   "x":margin, "y":margin,
                   "class":"box"
            });

var bubbleGroup = svg.append("g")
        .attr("transform", 
              "translate(" + [margin,margin] + ")");
    
    //__Initialize layout objects__//

var colorScale = d3.scale.linear().domain([changeMin,-0.00000000000001,0.00000000000001,2]).range(["#ff0303","#ffa3ba","#c2ff99","#0dbf00"])
  
d3.layout.pack()
    .sort((
        sortOrder?
            ( (sortOrder<0)? 
                function(a,b){return b.size - a.size;} : //descending
                function(a,b){return a.size - b.size;} ) : //ascending
            function(a,b){return 0;} //no sort
        ))
    .size([width/scaleFactor, height/scaleFactor])
    .value(function(d) { return d.size; })
    .nodes({children:data});
    
//Use the force layout to optimize:
var force = d3.layout.force()
    .nodes(data)
    .size([width/scaleFactor, height/scaleFactor])
    .gravity(.1)
    .charge(0) //don't repel
    .on("tick", updateBubbles);
    
    
    //Create circles!//
var bubbles = bubbleGroup.selectAll("circle")
    .data(data)          
    .enter()
        .append("circle")
        .style("fill",function(d) { return colorScale(d.pct_change); })
        .style("stroke", "black")
        .style("opacity",0.7)
         .on("mouseover", function(d) { 
            d3.select(this).style("stroke", "red");
            div.transition()    
                .duration(200)    
                .style("opacity", .9);    
            div .html("Service: "+ d.id + "<br/>"+ "Allocated expenditure (2016/17): " + MoneyFormat(d.ty) +  "<br/>"+ "Allocated expenditure (2015/16): " + MoneyFormat(d.ly) + "<br/>"  + "Overall Change: " + PctFormat(d.pct_change))  
                .style("left", (d3.event.pageX) + "px")   
                .style("top", (d3.event.pageY - 28) + "px");  
            })          
        .on("mouseout", function(d) {   
            div.transition()    
                .duration(500) 
                .style("opacity", 0); 
                d3.select(this).style("stroke", "black");   
        });
  
     
// Create a function for this tick round,
// with a new quadtree to detect collisions 
// between a given data element and all
// others in the layout, or the walls of the box.
    
    
//keep track of max and min positions from the quadtree
var bubbleExtent;
function collide(alpha) {
  var quadtree = d3.geom.quadtree(data);
  var maxRadius = Math.sqrt(dataMax);
  var scaledPadding = padding/scaleFactor;
  var boxWidth = width/scaleFactor;
  var boxHeight = height/scaleFactor;
    
    //re-set max/min values to min=+infinity, max=-infinity:
  bubbleExtent = [[Infinity, Infinity],[-Infinity, -Infinity]];
    
  return function(d) {
      //check if it is pushing out of box:
    var r = Math.sqrt(d.size) + scaledPadding,
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
      
      if (nx1 < 0) {
           d.x = r;
      }
      if (nx2 > boxWidth) {
           d.x = boxWidth - r;
      }
      if (ny1 < 0) {
           d.y = r;
      }
      if (ny2 > boxHeight) {
           d.y = boxHeight - r;
      }
      
      
    //check for collisions
    r = r + maxRadius, 
        //radius to center of any possible conflicting nodes
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
      
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== d)) {
        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y),
            r = Math.sqrt(d.size) + Math.sqrt(quad.point.size)
                    + scaledPadding;
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
    //update max and min
    r = r-maxRadius; //return to radius for just this node
    bubbleExtent[0][0] = Math.min(bubbleExtent[0][0], 
                                  d.x - r);
    bubbleExtent[0][1] = Math.min(bubbleExtent[0][1], 
                                  d.y - r);
    bubbleExtent[1][0] = Math.max(bubbleExtent[1][0], 
                                  d.x + r);
    bubbleExtent[1][1] = Math.max(bubbleExtent[1][1], 
                                  d.y + r);
      
  };
}  

function updateBubbles() {
    
    bubbles
        .each( collide(.2) ); //check for collisions   
    
    //update the scale to squeeze in the box 
    //to match the current extent of the bubbles
    var bubbleWidth = bubbleExtent[1][0] - bubbleExtent[0][0];
    var bubbleHeight = bubbleExtent[1][1] - bubbleExtent[0][1];
    
    scaleFactor = (height/bubbleHeight +
                           width/bubbleWidth)/2; //average
    /*
    console.log("Box dimensions:", [height, width]);
    console.log("Bubble dimensions:", [bubbleHeight, bubbleWidth]);
    console.log("ScaledBubble:", [scaleFactor*bubbleHeight,
                                 scaleFactor*bubbleWidth]);
    //*/
    
    rScale
        .range([0,  Math.sqrt(dataMax)*scaleFactor]);
    
    //shift the bubble cluster to the top left of the box
    bubbles
        .each( function(d){
            d.x -= bubbleExtent[0][0];
            d.y -= bubbleExtent[0][1];
        });
       
    //update positions and size according to current scale:
    bubbles
        .attr("r", function(d){return rScale(d.size);} )
        .attr("cx", function(d){return scaleFactor*d.x;})
        .attr("cy", function(d){return scaleFactor*d.y;})
}

force.start();

});

</script>